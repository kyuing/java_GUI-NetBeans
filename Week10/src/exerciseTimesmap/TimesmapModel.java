package exerciseTimesmap;


import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Statement;
import java.time.Instant;
import java.util.Date;
import java.util.logging.Level;
import java.util.logging.Logger;

public class TimesmapModel {
    
    //private accesses
    private String dbServer = "jdbc:mysql://localhost:3306/times?useUnicode=true&useJDBCCompliantTimezoneShift=true&useLegacyDatetimeCode=false&serverTimezone=GMT&autoReconnect=true&useSSL=false"; 
    private String user = "root";   //private class-level user
    private String pwd = "smokingharmsyou";    //private class-level pwd
    private Connection conn = null; //private class-level conn
    
    private ResultSet rs; //" A table of data representing a database result set, which is usually generated by executing a statement that queries the database."
    private Statement stmt = null;  //"Statement class: the object used for executing a static SQL statement and returning the results it produces"
    private ResultSetMetaData rsmd; //for columns. not in use
    private int rowSize; //row size from epochRetriever()

    //method that regurns all the rows from DB to JList
    public String[] epochRetriever() {
        
        String[] data = null;
        
        try {   //need try-catch since the external sql is.
        
            /** interface ResultSet */
            rs = stmt.executeQuery("SELECT count(*) FROM times;");
            rs.next();
            rowSize = rs.getInt("count(*)");
            System.out.println("no. of rows: " + rowSize);
            
            data = new String[rowSize]; //initialize the row size
            rs = stmt.executeQuery("SELECT * FROM times");    //now, retireve the result
            
            int i = 0;  //counter

            //loop through the result set
            while(rs.next()) {
            
                //take Epoch Milli times from the DB
                long epoch = rs.getLong(1); // == long epoch = rs.getLong("time");
                System.out.println(epoch);
                data[i] = Long.toString(epoch); //== //data[i] = String.valueOf(epoch);
                i++;        
                            
                //convertion to current time format can be done here but let's do the convertion in separate
    
            }
                
            //close the result set, statement and the connection
            rs.close();
            closeStmtConn();  //don't close stmt & conn for dynamic updating within the project

        }catch(SQLException se) {
            //SQLException: An exception that provides information on a database access error or other errors.
            System.out.println("SQLException se:");
            
            //loop through the SQLException
            while(se != null) {
                System.out.println("se.getSQLState(): " + se.getSQLState());    //retrieves the SQLState for this <code>SQLException</code> object.
                System.out.println("se.getMessage(): " + se.getMessage());  //returns  the detail message string of this {@code Throwable} instance(which may be {@code null}).
                System.out.println("se.getErrorCode(): " + se.getErrorCode());  //retrieves the vendor-specific exception code for this <code>SQLException</code> object.
                se = se.getNextException(); //returns the next <code>SQLException</code> object in the chain; <code>null</code> if there are none
            }          
        }catch (Exception e) {
        /*the class {@code Exception} and its subclasses are a form of
         * {@code Throwable} that indicates conditions that a reasonable
         * application might want to catch. */
            System.out.println(e);
        }        
        return data;
    }

    //method that returns an unix time format to crrent time format. no need any DB connection
    public String[] selectedListToCT(String t) {
        
        String[] data = new String[1];  //initialize it

        /* convert it to current time format.
         * the processes are not really efficent but i've only one row. 

         * String t is a plain string type but it should be regarded back as a Long type
         * to get a current time format from a Long type variable. 
         * Thus it needs to be parsed back to be a Long type    
         * an unix time * 1000 gives a curren time format */

        /*********************************************************************************************
            # this works as well.
            
            Instant current = Instant.ofEpochMilli(Long.valueOf(t) * 1000);    //string t to Long t
            data[0] = current.toString();   //long t back to string t
        **********************************************************************************************/
        
        //However, it looks neater.
        Long unixT = Long.valueOf(t) * 1000;    //an unix time * 1000
        Date current = new Date(unixT); //declare and init an instace of Date with the unixT

        data[0] = current.toString();   //the instace current is still not a string type so convert it to be so.
        System.out.println("data[0]: " + data[0]);
        
        return data;
    }
    
    //method that returns the initial form of the table
    public String[][] fieldManager() {
        
        String[][] data = new String[1][1]; //init it

            data[0][0] = "Click the options above";   //just prompt as a instruction
            System.out.println(data[0]);
        
        return data;
    }

    /*************************** dbConnector() & closeStmtConn() *******************************************************/
    public void dbConnector() {
    
        try{
            
            //Class.forName("com.mysql.cj.jdbc.Driver").newInstance(); 
            //Class.forName("com.mysql.jdbc.Driver").newInstance(); 
            
            /**
            * .getConnection() attempts to establish a connection to the given database URL.
            * @param url a database url of the form
            * @param password the user's password
            * @return a connection to the URL */
            conn = DriverManager.getConnection(dbServer, user, pwd);   //a connection to the db specified

            /**
            * Statement class: the object used for executing a static SQL statement and returning the results it produces
            * createStatement(): creates a <code>Statement</code> object for sending SQL statements to the database.  */
            stmt = conn.createStatement() ; // Get a statement from the connection

        }
        catch(SQLException se){
            //SQLException: An exception that provides information on a database access error or other errors.
            System.out.println( "SQL Exception:" );

            // Loop through the SQL Exceptions
            while(se != null){
                System.out.println("se.getSQLState(): " + se.getSQLState());    //retrieves the SQLState for this <code>SQLException</code> object.
                System.out.println("se.getMessage(): " + se.getMessage());  //returns  the detail message string of this {@code Throwable} instance(which may be {@code null}).
                System.out.println("se.getErrorCode(): " + se.getErrorCode());  //retrieves the vendor-specific exception code for this <code>SQLException</code> object.
                se = se.getNextException(); //returns the next <code>SQLException</code> object in the chain; <code>null</code> if there are none
            }
        }
        catch( Exception e ){
            /*the class {@code Exception} and its subclasses are a form of
             * {@code Throwable} that indicates conditions that a reasonable
             * application might want to catch. */
            System.out.println(e);
        }
    }
    
    public void closeStmtConn(){

        try {            
            stmt.close();   //close statement
            conn.close();   //close connection
        }
        catch (SQLException ex) {
            /**
             * Logging is used to store exceptions, information, and warnings 
             * as messages that occur during the execution of a program. 
             * Logging helps a programmer in the debugging process of a program. 
             * Java provides logging facility in the java.util.logging package
             */
            Logger.getLogger(TimesmapModel.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
 
}