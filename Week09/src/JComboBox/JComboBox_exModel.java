package JComboBox;


import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.logging.Level;
import java.util.logging.Logger;

public class JComboBox_exModel {
    
    //private accesses
    private String dbServer = "jdbc:mysql://localhost:3306/[table]?useUnicode=true&useJDBCCompliantTimezoneShift=true&useLegacyDatetimeCode=false&serverTimezone=GMT&autoReconnect=true&useSSL=false"; 
    private String user = "";   //private class-level user
    private String pwd = "";    //private class-level pwd
    private Connection conn = null; //private class-level conn
    
    private ResultSet rs; //" A table of data representing a database result set, which is usually generated by executing a statement that queries the database."
    private Statement stmt = null;  //"Statement class: the object used for executing a static SQL statement and returning the results it produces"
    private ResultSetMetaData rsmd; //for columns
    private String selectedFname, selectedLname; //customer names
    private int rowSize_selectCnameFromDB; //row size form selectCnameFromDB();
    
    //method that returns customer's first name and second name
    public String[] selectCnameFromDB() {
        
        String[] data = null;
        
        try {   //need try-catch since the external sql is.

            //the queries to select all the rows from a DB and assign them to JComboBox
            
            /** interface ResultSet */
            rs = stmt.executeQuery("SELECT count(*) FROM customers;");
            rs.next();
            rowSize_selectCnameFromDB = rs.getInt("count(*)");
            System.out.println("no. of rows: " + rowSize_selectCnameFromDB);
            
            data = new String[rowSize_selectCnameFromDB]; //initialize the row size
            rs = stmt.executeQuery("SELECT * FROM customers");    //now, retireve the result
            
            int i = 0;  //counter
            //loop through the result set
            while(rs.next()) {
            
                //the value will dynamically be updated by the codes in actionPerFormed() once an action is found in the view 
                data[i] = rs.getString("fname") + "  " + rs.getString("lname");   //get customer name
                i++;        
                
                //assign the user name to String variables selectedFname and selectedLname for testing
                this.selectedFname = rs.getString("fname");
                this.selectedLname = rs.getString("lname");
            }
            
            /**
             * Once this 1D array <method>selectCnameFromDB()</method> is returned to
             * the instance of JComboBox at the controller class, 
             * this method won't be used again. The job allocated is done.
             * 
             * The query executed above is for the instance of JcomboBox to have 
             * all the names  from the existing row.
             * So, any specific row can not be executed only.
             * Consequently, rs.getString() from the DB returns the last row to this method.
             * 
             */
            System.out.println("this.selectedFname at selectCnameFromDB(): " + this.selectedFname);
            System.out.println("this.selectedLname at selectCnameFromDB(): " + this.selectedLname);
                
            //close the result set, statement and the connection
            rs.close();
            //closeStmtConn();  //don't close stmt & conn for dynamic updating within the project

        }catch(SQLException se) {
            //SQLException: An exception that provides information on a database access error or other errors.
            System.out.println("SQLException se:");
            
            //loop through the SQLException
            while(se != null) {
                System.out.println("se.getSQLState(): " + se.getSQLState());    //retrieves the SQLState for this <code>SQLException</code> object.
                System.out.println("se.getMessage(): " + se.getMessage());  //returns  the detail message string of this {@code Throwable} instance(which may be {@code null}).
                System.out.println("se.getErrorCode(): " + se.getErrorCode());  //retrieves the vendor-specific exception code for this <code>SQLException</code> object.
                se = se.getNextException(); //returns the next <code>SQLException</code> object in the chain; <code>null</code> if there are none
            }          
        }catch (Exception e) {
        /*the class {@code Exception} and its subclasses are a form of
         * {@code Throwable} that indicates conditions that a reasonable
         * application might want to catch. */
            System.out.println(e);
        }        
        return data;
    }
    
    //method that returns administrator's first name and second name
    public String[] selectAnameFromDB() {
        
        String[] data = null;
        
        try {   //need try-catch since the external sql is.

            //the queries to select all the rows from a DB and assign them to JComboBox
            
            /** interface ResultSet */
            rs = stmt.executeQuery("SELECT count(*) FROM admins;");
            rs.next();
            rowSize_selectCnameFromDB = rs.getInt("count(*)");
            System.out.println("no. of rows: " + rowSize_selectCnameFromDB);
            
            data = new String[rowSize_selectCnameFromDB]; //initialize the row size
            rs = stmt.executeQuery("SELECT * FROM admins");    //now, retireve the result
            
            int i = 0;  //counter
            //loop through the result set
            while(rs.next()) {
            
                //the value will dynamically be updated by the codes in actionPerFormed() once an action is found in the view 
                data[i] = rs.getString("fname") + "  " + rs.getString("lname");   //get customer name
                i++;        
                
                //assign the user name to String variables selectedFname and selectedLname for testing
                this.selectedFname = rs.getString("fname");
                this.selectedLname = rs.getString("lname");
            }
            
            /**
             * Once this 1D array <method>selectCnameFromDB()</method> is returned to
             * the instance of JComboBox at the controller class, 
             * this method won't be used again. The job allocated is done.
             * 
             * The query executed above is for the instance of JcomboBox to have 
             * all the names  from the existing row.
             * So, any specific row can not be executed only.
             * Consequently, rs.getString() from the DB returns the last row to this method.
             * 
             */
            System.out.println("this.selectedFname at selectCnameFromDB(): " + this.selectedFname);
            System.out.println("this.selectedLname at selectCnameFromDB(): " + this.selectedLname);
                
            //close the result set, statement and the connection
            rs.close();
            //closeStmtConn();  //don't close stmt & conn for dynamic updating within the project

        }catch(SQLException se) {
            //SQLException: An exception that provides information on a database access error or other errors.
            System.out.println("SQLException se:");
            
            //loop through the SQLException
            while(se != null) {
                System.out.println("se.getSQLState(): " + se.getSQLState());    //retrieves the SQLState for this <code>SQLException</code> object.
                System.out.println("se.getMessage(): " + se.getMessage());  //returns  the detail message string of this {@code Throwable} instance(which may be {@code null}).
                System.out.println("se.getErrorCode(): " + se.getErrorCode());  //retrieves the vendor-specific exception code for this <code>SQLException</code> object.
                se = se.getNextException(); //returns the next <code>SQLException</code> object in the chain; <code>null</code> if there are none
            }          
        }catch (Exception e) {
        /*the class {@code Exception} and its subclasses are a form of
         * {@code Throwable} that indicates conditions that a reasonable
         * application might want to catch. */
            System.out.println(e);
        }        
        return data;
    }
    
    //method that returns a row of customer info from a DB with customer's first name and second name
    public String[] selectedFullNames(String fname, String lname) {
        
        String[] data = null;
        
        try {   //need try-catch since the external sql is.

            /** interface ResultSet */
            rs = stmt.executeQuery("SELECT count(*) FROM customers WHERE fname = '" + fname +  "' AND lname = '" + lname +  "' ;");
            rs.next();
            
            int rowSize = rs.getInt("count(*)");
            System.out.println("no. of rows at selectedFullNames(String fname, String lname): " + rowSize);

            rs = stmt.executeQuery("SELECT * FROM customers WHERE fname = '" + fname +  "' AND lname = '" + lname +  "' ;");    //now, retireve the result
            
            rsmd = rs.getMetaData();    //get columns
            int colSize = rsmd.getColumnCount();    //store the columns counted into colSize
            System.out.println("no. of cols at selectedFullNames(String fname, String lname): " + colSize);
            

            data = new String[colSize]; //initialize the col size. need col size for now            
            //loop through the result set
            while(rs.next()) {

                for(int i=0; i<colSize; i++) {
                    //sql column starts with 1
                    data[i] = rs.getString(i+1);  //get the value of the columns each
                }
            }
            rs.close();
            //closeStmtConn();  //don't close stmt & conn for dynamic updating within the project

        }catch(SQLException se) {
            //SQLException: An exception that provides information on a database access error or other errors.
            System.out.println("SQLException se:");
            
            //loop through the SQLException
            while(se != null) {
                System.out.println("se.getSQLState(): " + se.getSQLState());    //retrieves the SQLState for this <code>SQLException</code> object.
                System.out.println("se.getMessage(): " + se.getMessage());  //returns  the detail message string of this {@code Throwable} instance(which may be {@code null}).
                System.out.println("se.getErrorCode(): " + se.getErrorCode());  //retrieves the vendor-specific exception code for this <code>SQLException</code> object.
                se = se.getNextException(); //returns the next <code>SQLException</code> object in the chain; <code>null</code> if there are none
            }          
        }catch (Exception e) {
        /*the class {@code Exception} and its subclasses are a form of
         * {@code Throwable} that indicates conditions that a reasonable
         * application might want to catch. */
            System.out.println(e);
        }        
        return data;
    }
    
    //method that returns a row of admin info from a DB with admin's first name and second name
    public String[] selectedFullNames_adm(String fname, String lname) {
        
        String[] data = null;
        
        try {   //need try-catch since the external sql is.

            /** interface ResultSet */
            rs = stmt.executeQuery("SELECT count(*) FROM admins WHERE fname = '" + fname +  "' AND lname = '" + lname +  "' ;");
            rs.next();
            
            int rowSize = rs.getInt("count(*)");
            System.out.println("no. of rows at selectedFullNames(String fname, String lname): " + rowSize);

            rs = stmt.executeQuery("SELECT * FROM admins WHERE fname = '" + fname +  "' AND lname = '" + lname +  "' ;");    //now, retireve the result
            
            rsmd = rs.getMetaData();    //get columns
            int colSize = rsmd.getColumnCount();    //store the columns counted into colSize
            System.out.println("no. of cols at selectedFullNames(String fname, String lname): " + colSize);
            

            data = new String[colSize]; //initialize the col size. need col size for now            
            //loop through the result set
            while(rs.next()) {

                for(int i=0; i<colSize; i++) {
                    //sql column starts with 1
                    data[i] = rs.getString(i+1);  //get the value of the columns each
                }
            }
            rs.close();
            //closeStmtConn();  //don't close stmt & conn for dynamic updating within the project

        }catch(SQLException se) {
            //SQLException: An exception that provides information on a database access error or other errors.
            System.out.println("SQLException se:");
            
            //loop through the SQLException
            while(se != null) {
                System.out.println("se.getSQLState(): " + se.getSQLState());    //retrieves the SQLState for this <code>SQLException</code> object.
                System.out.println("se.getMessage(): " + se.getMessage());  //returns  the detail message string of this {@code Throwable} instance(which may be {@code null}).
                System.out.println("se.getErrorCode(): " + se.getErrorCode());  //retrieves the vendor-specific exception code for this <code>SQLException</code> object.
                se = se.getNextException(); //returns the next <code>SQLException</code> object in the chain; <code>null</code> if there are none
            }          
        }catch (Exception e) {
        /*the class {@code Exception} and its subclasses are a form of
         * {@code Throwable} that indicates conditions that a reasonable
         * application might want to catch. */
            System.out.println(e);
        }        
        return data;
    }

    /**
     * This will return the first row from the DB 
     * which has nothing to do with JCombo box
     * before & after any action is triggered.
     * This ONLY provides a template of the row field in the JTble instance.
     * any dynamic update will be implemented from 
     * <method>String[] selectedFullNames(String fname, String lname)</method> above.
     * (Because JComboBox by default shows the first item in a DB before any action
     * and <method>String[] selectCnameFromDB()</method> the last row in a DB before any action)
     * 
     */
    public String[][] selectCRowFromDB() {
        
        String[][] data = null;
        
        try {   //need try-catch since the external sql is.

            //ONLY 1st row is in need 
            data = new String[1][5]; //initialize the array
            rs = stmt.executeQuery("SELECT * FROM customers ORDER BY c_ID ASC limit 1;");    //now, retireve the result

            //int i=0, j=0;  //counters. not in use
            
            //loop through the result set
            while(rs.next()) {

                for(int i=0; i<1; i++) {
                    for(int j=0; j<5; j++) {
                        
                        //sql column starts with 1
                        data[i][j] = rs.getString(j+1);  //get the values each
                    }
                }
                
                System.out.println("fanme retireved: " + rs.getString(3));
                System.out.println("lanme retireved: " + rs.getString(4));

                /**********************************************
                this works as well.
                //get data
                data[i][0] = rs.getString("c_ID");  
                data[i][1] = rs.getString("users_username");  
                data[i][2] = rs.getString("fname");  
                data[i][3] = rs.getString("lname");  
                data[i][4] = rs.getString("email");  
                i++;
                ***********************************************/    
            }

            //close the result set, statement and the connection
            //this method is used only once.
            rs.close();
            closeStmtConn();

        }catch(SQLException se) {
            //SQLException: An exception that provides information on a database access error or other errors.
            System.out.println("SQLException se:");
            
            //loop through the SQLException
            while(se != null) {
                System.out.println("se.getSQLState(): " + se.getSQLState());    //retrieves the SQLState for this <code>SQLException</code> object.
                System.out.println("se.getMessage(): " + se.getMessage());  //returns  the detail message string of this {@code Throwable} instance(which may be {@code null}).
                System.out.println("se.getErrorCode(): " + se.getErrorCode());  //retrieves the vendor-specific exception code for this <code>SQLException</code> object.
                se = se.getNextException(); //returns the next <code>SQLException</code> object in the chain; <code>null</code> if there are none
            }          
        }catch (Exception e) {
        /*the class {@code Exception} and its subclasses are a form of
         * {@code Throwable} that indicates conditions that a reasonable
         * application might want to catch. */
            System.out.println(e);
        }        
        return data;
    }
    
    //a method that provides initial admin table setting
    public String[][] selectAdmRowFromDB() {
        
        String[][] data = null;
        
        try {   //need try-catch since the external sql is.

            //ONLY 1st row is in need 
            data = new String[1][5]; //initialize the array
            rs = stmt.executeQuery("SELECT * FROM admins ORDER BY adm_ID ASC limit 1;");    //now, retireve the result

            //int i=0, j=0;  //counters. not in use
            
            //loop through the result set
            while(rs.next()) {

                for(int i=0; i<1; i++) {
                    for(int j=0; j<5; j++) {
                        
                        //sql column starts with 1
                        data[i][j] = rs.getString(j+1);  //get the values each
                    }
                }
                
                System.out.println("fanme retireved: " + rs.getString(3));
                System.out.println("lanme retireved: " + rs.getString(4));

            }

            //close the result set, statement and the connection
            //this method is used only once.
            rs.close();
            closeStmtConn();

        }catch(SQLException se) {
            //SQLException: An exception that provides information on a database access error or other errors.
            System.out.println("SQLException se:");
            
            //loop through the SQLException
            while(se != null) {
                System.out.println("se.getSQLState(): " + se.getSQLState());    //retrieves the SQLState for this <code>SQLException</code> object.
                System.out.println("se.getMessage(): " + se.getMessage());  //returns  the detail message string of this {@code Throwable} instance(which may be {@code null}).
                System.out.println("se.getErrorCode(): " + se.getErrorCode());  //retrieves the vendor-specific exception code for this <code>SQLException</code> object.
                se = se.getNextException(); //returns the next <code>SQLException</code> object in the chain; <code>null</code> if there are none
            }          
        }catch (Exception e) {
        /*the class {@code Exception} and its subclasses are a form of
         * {@code Throwable} that indicates conditions that a reasonable
         * application might want to catch. */
            System.out.println(e);
        }        
        return data;
    }

    /*************************** dbConnector() & closeStmtConn() *******************************************************/
    public void dbConnector() {
    
        try{
            
            //Class.forName("com.mysql.cj.jdbc.Driver").newInstance(); 
            //Class.forName("com.mysql.jdbc.Driver").newInstance(); 
            
            /**
            * .getConnection() attempts to establish a connection to the given database URL.
            * @param url a database url of the form
            * @param password the user's password
            * @return a connection to the URL */
            conn = DriverManager.getConnection(dbServer, user, pwd);   //a connection to the db specified

            /**
            * Statement class: the object used for executing a static SQL statement and returning the results it produces
            * createStatement(): creates a <code>Statement</code> object for sending SQL statements to the database.  */
            stmt = conn.createStatement() ; // Get a statement from the connection

        }
        catch(SQLException se){
            //SQLException: An exception that provides information on a database access error or other errors.
            System.out.println( "SQL Exception:" );

            // Loop through the SQL Exceptions
            while(se != null){
                System.out.println("se.getSQLState(): " + se.getSQLState());    //retrieves the SQLState for this <code>SQLException</code> object.
                System.out.println("se.getMessage(): " + se.getMessage());  //returns  the detail message string of this {@code Throwable} instance(which may be {@code null}).
                System.out.println("se.getErrorCode(): " + se.getErrorCode());  //retrieves the vendor-specific exception code for this <code>SQLException</code> object.
                se = se.getNextException(); //returns the next <code>SQLException</code> object in the chain; <code>null</code> if there are none
            }
        }
        catch( Exception e ){
            /*the class {@code Exception} and its subclasses are a form of
             * {@code Throwable} that indicates conditions that a reasonable
             * application might want to catch. */
            System.out.println(e);
        }
    }
    
    public void closeStmtConn(){

        try {            
            stmt.close();   //close statement
            conn.close();   //close connection
        }
        catch (SQLException ex) {
            /**
             * Logging is used to store exceptions, information, and warnings 
             * as messages that occur during the execution of a program. 
             * Logging helps a programmer in the debugging process of a program. 
             * Java provides logging facility in the java.util.logging package
             */
            Logger.getLogger(JComboBox_exModel.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
 
}